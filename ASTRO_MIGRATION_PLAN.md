# Migration Plan: FastHTML to Astro

## 1. Objective
Decouple the "Brain" (Python Data Pipeline) from the "Face" (Frontend UI) by migrating from FastHTML to Astro. This will improve site performance, SEO stability, and significantly increase the autonomy of AI agents working on the codebase.

## 2. Core Architectural Principles
*   **Decoupled SSG**: Python remains the source of truth for data enrichment. Astro fetches this data at build time to generate a 100% static site.
*   **Contract First**: The existing URL structure and data schema are treated as sacred.
*   **Parity First**: The first milestone is absolute functional and visual parity. We will port existing CSS and logic rather than redesigning.

## 3. Data & URL Contract (The "Sacred" Rules)
To avoid SEO regressions, the following must remain unchanged:
*   **URL Patterns**: 
    *   `/tools/{slug}`
    *   `/compare/{slug}`
    *   `/category/{slug}`
    *   `/comparisons` (The hub)
*   **Trailing Slashes**: Must remain **disabled** (e.g., `/tools/chatgpt` not `/tools/chatgpt/`).
*   **Slug Registry**: The `slug_registry.json` generated by the Python pipeline remains the sole authority for URL paths.

## 4. Implementation Strategy

### Phase 1: Data Sync Bridge
We will implement a `scripts/sync-frontend-data.py` utility.
*   **Build-time Fetch**: During the CI/CD build process, this script will fetch `tools.json` and `slug_registry.json` from MinIO.
*   **Local Persistence**: Data will be stored in `frontend/src/content/tools.json` for Astro to consume.
*   **Security**: To simplify build-time access, we will either use build-time environment secrets or make the data bundle available via a private internal endpoint.

### Phase 2: Content Collections & Schema
We will use Astro's **Content Collections** with a JSON loader.
*   **Validation**: Use `Zod` to define a strict schema for tools. This ensures that any "broken" data from the AI pipeline (e.g., missing names or invalid URLs) fails the build loudly before deployment.
*   **Routing**: Use `getStaticPaths()` to map the `slug_registry.json` directly to Astro file routes.

### Phase 3: Component Porting
*   **Styles**: Directly import `ai_tools_website/v1/static/styles.css` into the Astro `BaseLayout`. No Tailwind conversion in Milestone 1 to prevent "coding hell."
*   **Search**: Port the existing `search.js` logic (DOM hide/show) as a client-side "Island." This is proven to be fast for ~500 tools.
*   **Markdown**: Use Astro's `<Content />` or a Markdown component to render tool descriptions. **Safety Check**: Implement standard sanitization to prevent XSS from AI-generated content.

### Phase 4: SEO & Sitemaps
*   **Sitemaps**: To maintain filename parity, we will either:
    1.  Continue using the Python `sitemap_builder.py` and copy the output into Astro's `public/` folder during the sync step.
    2.  Configure Astro's sitemap plugin to match the exact existing directory structure (`/sitemaps/sitemap-tools.xml`).
*   **Analytics**: Port the dual-track Umami scripts into the global `<head>` of the `BaseLayout`.

## 5. Discussion Points & Risks
1.  **Rebuild Triggers**: Since the site is now static (SSG), we must trigger a frontend rebuild whenever the Python pipeline updates the data. We need to wire a "Build Frontend" webhook into the `run-update.sh` script.
2.  **Redirect Maps**: If we ever change a slug in the Python brain, we need a way to generate static 301 redirect pages (using `<meta http-equiv="refresh">`) or Nginx-level maps.
3.  **MinIO Build Access**: We need to confirm if the Coolify build environment has network visibility to the MinIO endpoint or if we should use an API Key.

## 6. Next Steps
1.  Initialize Astro project in `/frontend`.
2.  Create the `sync-frontend-data.py` script.
3.  Build the `BaseLayout.astro` with Umami and legacy CSS.
4.  Implement `[slug].astro` for tool and comparison pages.
